diff --git a/modules/flowdrop_node_processor/src/Plugin/FlowDropNodeProcessor/EntitySave.php b/modules/flowdrop_node_processor/src/Plugin/FlowDropNodeProcessor/EntitySave.php
index d7d2bcd..7122f36 100644
--- a/modules/flowdrop_node_processor/src/Plugin/FlowDropNodeProcessor/EntitySave.php
+++ b/modules/flowdrop_node_processor/src/Plugin/FlowDropNodeProcessor/EntitySave.php
@@ -6,6 +6,8 @@
 
 use Drupal\Core\Entity\EntityTypeManagerInterface;
 use Drupal\Core\Entity\FieldableEntityInterface;
+use Drupal\Core\Entity\RevisionableInterface;
+use Drupal\Core\Entity\RevisionLogInterface;
 use Drupal\Core\StringTranslation\TranslatableMarkup;
 use Drupal\flowdrop\Attribute\FlowDropNodeProcessor;
 use Drupal\flowdrop\DTO\ParameterBagInterface;
@@ -123,6 +125,8 @@ public function process(ParameterBagInterface $params): array {
     $values = $params->getArray("values", []);
     $bundle = $params->getString("bundle", "");
     $allowedFields = $params->getArray("allowed_fields", []);
+    $createRevision = $params->getBool("create_revision", FALSE);
+    $revisionLogMessage = $params->getString("revision_log_message", "");
 
     // Validate entity type exists.
     if (empty($entityType)) {
@@ -181,6 +185,26 @@ public function process(ParameterBagInterface $params): array {
       $entity = $storage->create($createValues);
     }
 
+    // Handle revision creation if configured and entity supports revisions.
+    $revisionCreated = FALSE;
+    if ($createRevision && $entity instanceof RevisionableInterface) {
+      // Set the entity to create a new revision on save.
+      $entity->setNewRevision(TRUE);
+      $revisionCreated = TRUE;
+
+      // Set the revision log message if the entity supports it.
+      if ($entity instanceof RevisionLogInterface && !empty($revisionLogMessage)) {
+        $entity->setRevisionLogMessage($revisionLogMessage);
+        $entity->setRevisionCreationTime(\Drupal::time()->getRequestTime());
+
+        // Set the revision user to the current user if available.
+        $currentUser = \Drupal::currentUser();
+        if ($currentUser->isAuthenticated()) {
+          $entity->setRevisionUserId((int) $currentUser->id());
+        }
+      }
+    }
+
     // Save the entity.
     $entity->save();
 
@@ -205,8 +229,14 @@ public function process(ParameterBagInterface $params): array {
       "changed" => method_exists($entity, "getChangedTime") ? $entity->getChangedTime() : NULL,
       "skipped_fields" => $skippedFields,
       "entity" => $serializedEntity,
+      "revision_created" => $revisionCreated,
     ];
 
+    // Add revision ID if entity supports revisions.
+    if ($entity instanceof RevisionableInterface) {
+      $output["revision_id"] = $entity->getRevisionId();
+    }
+
     // Add bundle information if applicable.
     $bundleKey = $definition->getKey("bundle");
     if ($bundleKey) {
@@ -308,6 +338,18 @@ public function getParameterSchema(): array {
             "type" => "string",
           ],
         ],
+        "create_revision" => [
+          "type" => "boolean",
+          "title" => "Create New Revision",
+          "description" => "When enabled, always creates a new revision on save (only applies to revisionable entities).",
+          "default" => FALSE,
+        ],
+        "revision_log_message" => [
+          "type" => "string",
+          "title" => "Revision Log Message",
+          "description" => "The log message to associate with the new revision (only used when create_revision is enabled).",
+          "default" => "",
+        ],
       ],
     ];
   }
@@ -355,6 +397,14 @@ public function getOutputSchema(): array {
           "type" => "array",
           "description" => "List of field names that were skipped due to allowed_fields restriction",
         ],
+        "revision_created" => [
+          "type" => "boolean",
+          "description" => "Whether a new revision was created on save",
+        ],
+        "revision_id" => [
+          "type" => "string",
+          "description" => "The revision ID of the saved entity (if revisionable)",
+        ],
         "entity" => [
           "type" => "object",
           "description" => "Full serialized entity data in the same format as Entity Trigger output",
